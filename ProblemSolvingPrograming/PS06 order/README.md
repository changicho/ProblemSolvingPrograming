# KDA

소환사의 협곡에서는 다양한 챔피언들이 싸우면서 전적을 남긴다.
여기서 전적은 KDA로 나타내는데, K는 다른 챔피언을 처치한 횟수, D는 죽은 횟수, A는 처치에 관여한 횟수다.
소환사의 협곡 사원인 티모는 전적들을 정해진 순서에 맞게 정리하는 업무를 맡고 있다.
정렬 규칙은 다음과 같으며, 번호 순으로 우선 순위가 적용된다.
K와 A를 합한 값을 D로 나눈 값이 높은 순서대로 정렬한다.
* 단, D가 0인 경우, 우선 순위가 부여되어 K와 A의 합이 높은 순으로 우선 정렬한다. 정렬되지 않는 경우, 규칙 3, 4번을 따른다.
D가 작은 순서대로 정렬한다.
이름 순으로 정렬한다.
위에서 언급한 규칙을 적용해도 정렬이 되지 않는 경우에는 입력 순으로 정렬한다.
챔피언 이름과 함께 각 챔피언의 KDA가 주어졌을 때, 순서에 맞게 정렬하여 출력하라.
단, Over death(K + A < D)인 경우는 정렬에서 제외한다.


입력
첫째 줄에 전적 정보의 개수 N이 주어진다.(0 < N <= 100)
둘째 줄부터 전적 정보가 주어진다. 전적 정보는 이름 K/D/A 순으로 입력된다.

출력
조건에 맞게 리스트를 정렬하여 한 줄에 전적 정보 하나씩 출력한다.

예제 입력
4
Lulu 10/1/6
Lux 2/5/7
Teemo 10/0/6
Bard 1/8/1

예제 출력
Teemo 10/0/6
Lulu 10/1/6
Lux 2/5/7

```
K+A/D가 소숫점으로 나오는 부분 고려, int형을 갖고 계산하기 때문에 Casting 필수이다.
vector 안의 요소의 수를 나타낼 때 .capacity 함수를 쓰지말자. 제대로 요소의 수가 나오지 않는다.
D가 모두 0일 때 어떻게 나오는지 고려하자.
```

# 버섯정렬

티모는 N개의 버섯을 가지고 있다. 정렬을 좋아하는 티모는 이 버섯들을 무게 순으로 정리하고 싶어한다.
하지만 티모가 가지고 있는 버섯은 매우 불안정하여 하나라도 잘못 건드리면 모든 버섯이 폭발해버린다.
따라서, 하나를 건드리더라도 다른 버섯은 영향이 없도록 연속으로 나열된 버섯이 연속된 값(무게)을 가지지 않게끔
(Mushroom[i] + 1 != Mushroom[i+1]) 정리하려고 한다.
규칙에 맞게 정렬된 버섯 리스트를 출력하시오.
만약, 가능한 경우의 수가 여러가지라면 사전 순으로 가장 앞서는 것을 출력한다.


입력
첫째 줄에 버섯의 개수 N이 주어진다.(0 < N <= 10000)
둘째 줄에 버섯들의 무게가 주어진다.

출력
정렬된 리스트를 출력한다.

입력 예제
3
1 2 3
9
1 1 1 1 2 2 2 2 2

출력 예제
1 3 2
2 2 2 2 2 1 1 1 1

```
처음에 제작한 알고리즘은 모든 일반경우에 맞지 않는다.
(뒤에서 하나씩 앞의것과 SWAP한 경우 사전순출력 갱신 -> 하나씩 SWAP하며 모든 경우 판단후 SWAP한 경우 출력 갱신)

힌트는 리스트에서 최소 값을 빼와서 정렬하는 것이다. 이대로 했더니 바로 풀렸다.

10
1 1 1 2 2 2 3 3 3 4

output
1 1 1 3 2 2 2 4 3 3
위의 케이스를 보면 답이 나온다.
```
