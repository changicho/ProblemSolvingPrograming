# Knight

N * N(N < 10) 크기의 체스판의 한 위치에서 Knight가 이동을 하여 체스판의 모든 칸들을 방문하려 한다.

Knight는 좌측 상단(-2, +1)부터 시계 방향(-1, +2 ~ +1, +2 ~ +2, +1 ...)으로 우선 순위를 두며 탐색한다.
이 때, 한 번 방문했던 칸은 방문하지 않으면서 모든 칸을 방문하려 한다.

예를 들어, 6 * 6 체스판에서 Knight가 (0,0)에 위치해 있다면 다음에 이동할 위치는 (1,2), (2,1)이 될 수 있다.

우선 순위에 따라 (1,2)를 먼저 방문하면, 그 다음 위치는 이미 방문한 경로인 (0,0)을 제외하고 (0,4), (2,4), (3,3) 등이 될 수 있다.

이런 식으로 6 * 6 체스판의 모든 칸(36개)을 방문하는 경로를 탐색하면 된다.

입력의 첫째 줄에는 체스판의 크기가 주어지며, 다음 줄에는 시작 위치가 주어진다.

출력은 이동한 위치를 차례로 출력한다. 답이 없는 경우에는 -1을 두 개 출력한다.

```
입력
6
0 0

출력

0 0
1 2
0 4
2 5
4 4
5 2
3 3
1 4
3 5
5 4
4 2
2 3
1 5
3 4
5 5
4 3
5 1
3 0
1 1
0 3
2 2
4 1
5 3
4 5
2 4
0 5
1 3
0 1
2 0
3 2
4 0
2 1
0 2
1 0
3 1
5 0
```

```
문제에 x, y 좌표 입력의 순서가 프로그래밍에서 생각하는 배열의 번호와 반대이다.
int kightX[MOVE] = { -2, -1, +1, +2, +2, +1, -1, -2 };
int kightY[MOVE] = { +1, +2, +2, +1, -1, -2, -2, -1 };
나이트의 이동순서이다.
이것을 고치니 바로 풀리더라.

계속 DFS 최적화의 문제라고 생각해서 고민했다.
6
0 0
의 경우 DFS를 약 5천번정도 호출.
```


# 게임 대회

티모는 협곡에서 열리는 K(1 <= K <= 60)인 대회 종목에 친구들을 내보내려 한다.

티모는 1부터 N까지 번호가 붙은 N(K <= N <= 900)명의 친구들 중에서 K명의 친구들을 엄선하여 대회에 참가하고자 한다.

하지만 티모의 친구들끼리 서로 어색한 사이면 게임에 집중을 할 수 없기 때문에 선발된 친구들이 모두 서로 친구 사이이길 원한다.

티모는 이러한 친구들의 관계에 대한 정보 F(1 <= F <= 5000)개를 가지고 있으며 이를 토대로 친구들을 선발하고자 한다.

입력은 선발할 친구들의 수 K, 전체 친구들의 수 N, 친구 관계 정보 개수 F가 첫번째 줄에 차례대로 주어지며,

그 다음줄부터 친구 관계 정보가 한 줄에 하나씩 입력된다.

여기서 친구 관계는 상호적이므로 2번 친구가 4번 친구와 친구 관계라면 4번 친구도 2번 친구와 친구 관계다.

만약, 조건에 맞게 친구들을 선발할 수 없다면 -1을 출력한다. 여러 경우가 존재한다면 오름차순 기준으로 가장 먼저 오는 경우를 출력한다.

```
입력
4 6 8
1 2
1 3
1 6
2 3
2 6
3 6
4 5
5 6

출력
1
2
3
6
```

```
정리 : 
그래프 혹은 집합의 문제이다.
그래프를 배운적이 없어 처음에 집합으로 해결하려 했으나 생각보다 복잡하다.

주의해야 할 점은 선발된 친구들이 모두 서로 친구여야 한다는 것이다. (주의)

if (visited[j] && !graph[i][j]) 이걸로
서로 친구 관계인지, 그리고 지나왔는지 확인한다.
if (visited[j] && !graph[i][j]) {
	pass = false;
}

이렇게 하면 지금까지 지나온 친구들끼리 서로 친구인지 확인할 수 있다.

my test case 1 : 
4 6 8
1 2
2 3
3 4
3 5
3 6
4 5
4 6
5 6

my test case 2 : 
4 6 6
1 3
1 5
1 6
3 5
3 6
5 6

두 번째 경우의 연결 관계인데, 중간에 연결이 띄워져 되있는 경우도 해결이 된다.
001011
000000
100011
000000
101001
101010

```
