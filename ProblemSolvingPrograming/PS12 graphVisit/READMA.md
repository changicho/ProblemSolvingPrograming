# 최단경로

 플로이드 알고리즘이란 정해진 그래프가 있을 때 그래프 내의 모든 정점에서 출발할 수 있고, 출발점을 제외한 모든 정점을 도착점으로 인식하여 그 최단거리를 구하는 알고리즘이다.
입력 첫째 줄에는 그래프 내의 정점 개수 N이 주어진다. 이후 입력한 정점들을 오름차순으로 정렬하여 각 간선의 가중치를 입력받는다(N^2).
예를 들어, 정점의 개수가 3인 경우 각 간선은 1-1, 1-2, 1-3, 2-1, 2-2, 2-3, 3-1, 3-2, 3-3 순으로 가중치를 입력받는 것이다.
여기서 가중치란 비용으로 인식하여 가중치가 적을수록 비용이 적게 드는 것이다.
다음으로 출발점과 도착점의 개수 M을 입력받는다.
마지막으로 M 줄에 걸쳐 출발점과 도착점 쌍을 입력받는다.
M개의 출발점과 도착점 사이의 최단 경로 비용을 출력하는 프로그램을 플로이드 알고리즘을 활용하여 작성하라.
출력은 M줄에 걸쳐 최단 경로가 표시되어야 한다.
경로 비용은 경로상의 모든 간선들의 가중치의 합이고, 최단경로는 경로비용이 가장 작은 경로이다.
```
입력
3
0
4
1
3
0
4
5
1
0
2
2 3
1 3

출력
4
1
```
```
백준 11404을 이용하면 간단하다.

플로이드 알고리즘을 사용해 미리 다 탐색해서 배열을 만들어놓고, 
행과 열을 입력받아 그 배열의 값을 출력하면 된다.

void floyd() {
	for (int i = 1; i <= vertex; i++) { // if i go by vertex
		for (int j = 1; j <= vertex; j++) { // from vertex
			for (int k = 1; k <= vertex; k++) { // to vertex
				if (arr[j][i] != INFINITE && arr[i][k] != INFINITE) {
					arr[j][k] = MIN(arr[j][k], arr[j][i] + arr[i][k]);
				}
			}
		}
	}
}

min(a-b 직접 가중치, a-c 가중치 + c-b 가중치)으로 구한다.
직접 가는 것과 다른 노드를 거쳐 가는 것의 최소.
```

# 메뚜기 채집

시장에 메뚜기를 팔아 돈을 버는 렝가는 오늘도 메뚜기를 채집하기 위해 산에 오른다.
하지만 무서운 호랑이가 산에 존재하기 때문에 날이 저물기 전에 산에서 내려오려고 한다.
렝가는 산의 지도를 보면서 집에서 출발하여 자신이 가장 높이 올라 갔다가 내려올 수 있는 위치를 알아내고 싶다.
집은 지도의 좌상단인(0,0)에 위치해 있다.
산의 높이는 A-Z로 표현되어 있고 0-25까지의 높이를 의미한다. 렝가는 인접한 좌표이면 상하좌우, 대각선 어디로든지 이동할 수 있다.
낮은 곳에서 높은 곳으로 이동할 때는 높이 차이의 제곱만큼의 시간이 걸리지만 높은 곳에서 낮은 곳으로 이동할때는 1시간만 걸린다.
예를 들어, A에서 C로 이동하려면 4시간(A->C는 2만큼 차이가 나고 2를 제곱하면 4가 됨), C에서 A로 이동할 때는 1시간(C->A로 내려오는 것이므로)이 걸린다. 단, 높이 차이가 너무 큰 곳은 올라갈 수도 내려갈 수도 없다.

산의 크기와 지도, 날이 저물기까지 남은 시간, 넘을 수 있는 최대 높이가 주어질 때, 렝가가 다녀올 수 있는 가장 높은 곳의 높이를 출력하라. (Z가 가장 높은 곳이라면 25가 된다.)
렝가는 집에서 출발해서 반드시 집으로 돌아 와야 한다.

입력 첫 줄은 [행 크기, 열 크기, 한 번에 오를 수 있는 최대 높이, 날이 저물기까지 남은 시간]이다.
다음 줄 부터는 X행 Y열 크기의 지도 행렬이 주어진다.
단, 입력은 한 개 이상의 테스트케이스가 아래와 같이 반복해서 나올 수 있다.
출력은 테스트케이스마다 1줄씩 출력해야 한다.

```
입력
6 6 6 30
ABCDED
DEFZFG
MLKJIH
NOPQRS
YXWVUT
ZAAAAA
6 6 6 31
ABCDED
DEFZFG
MLKJIH
NOPQRS
YXWVUT
ZAAAAA

출력
24
25
```

```
최대 높이를 갱신하는 것은 플로이드 알고리즘으로, 
최대 높이에서 돌아가는 것은 다이크스트라 알고리즘으로 구현한다. 

플로이드 함수 부분에서 거리를 구할 때, for 루프마다 
행, 열 일때를 따로 구분해서 총 6중 forloop로 구성했다.

이번 실습에서 
vector<vector<vector<vector<int> > > > distance; 
이 형태로 배열을 만들어서 동적할당을 했다.

차원별로 for 루프를 통해 동적 할당해줘야 하는 번거로움이 있는데 
이를 define으로 해결해야할지 의문이다.

distance[i_row][i_col][j_row][j_col] 
= MIN(distance[i_row][i_col][j_row][j_col]
, distance[i_row][i_col][k_row][k_col] + distance[k_row][k_col][j_row][j_col]);

루프 순서는 k_row, col/ i_row, col/ j_row, col 이다.
이렇게 각 좌표에서 다른 좌표로 도달하는 데에 
걸리는 시간을 배열로 만들었다. (4차원 배열)

중간에 산까지 갔다가 돌아오는 시간이 
제대로 더해지지 않아 답이 이상하게 나왔었다.
```
