# 협곡탈출

 협곡에는 티모의 유독성 함정이 곳곳에 깔려있다. 유독성 함정을 밟으면 체력이 깎이는데, 
 
 포션을 먹으면 어느정도 복구를 할 수 있다. 하지만 체력 포션의 양이 많지가 않아, 최소한으로 사용하여 협곡을 탈출하려고 한다.
 
 
입력으로 협곡의 크기와 정보가 주어진다. 알파벳은 유독성 함정의 데미지를 뜻하며, A는 0의 데미지를 뜻하며, Z는 25의 데미지를 뜻한다.

#은 이동할 수 없는 구간을 나타내며, $은 시작점, &는 도착점을 뜻한다.

1 데미지는 1 포션으로 복구가 가능하며, 당신은 시작점에서 출발해 포션을 최소한으로 사용하는 경로를 찾아 도착점에 도착해야한다.

이동은 상, 하, 좌, 우로만 이동할 수 있다.

이 때, 탈출에 사용된 포션의 개수를 출력하라.

```
입력
5 5
$C##F
BE##B
#BBBC
##FB#
BFBC&

출력
11
```

```
$ABCDEFGH&
0012345670

Dynamic Programming을 사용하지 않으면 시간 초과 에러가 발생한다.
답은 단순했다.
start에서 i,j까지 가중치를 저장하는 map_weight를 만들고
그것과 비교해서 작을때만 갱신하면 된다.
```

# 모래성

해변가에 놀러온 당신은 다음과 같은 규칙을 따라 튼튼한 모래성을 쌓으려고 한다.


1. N개의 열에 높이 1의 모래를 쌓아 1층 모래성을 만든다.(1 <= N <= 10,000)

2. 2층 이후부터는 같은 높이를 갖는 임의의 연속하는 열을 선택한 뒤, 
선택한 열에서 첫 번째 열과 마지막 열을 제외한 모든 층에 높이 1의 모래를 쌓는다.

3. 모래성은 반드시 최대 높이를 가질 필요가 없으며, 1층 모래성도 가능하다.

당신은 위의 규칙에 따라 튼튼하고 멋진 모래성을 만들었다!
하지만 머지 않아, 파도가 덮쳐오며 모래성을 휩쓸어 갔다. 

튼튼하게 지은 덕분인지 일부는 무너지지 않고 그대로 있었다.

그런데 모래성을 튼튼하게 짓는데 집중한 나머지, 어떤 모양으로 쌓았는지 기억이 나지 않는다. 
남아 있는 모래성 일부를 가지고 최대한 비슷하게 만들고자 한다.
남아 있는 모래성을 가지고 위의 규칙을 따라 만들었을 수 있는 가능한 경우의 수를 구하여라.


첫 번째 줄에 N이 주어지고 두 번째 줄에 남은 모래성에 대한 정보가 주어진다.

-1은 모래성 일부가 손실되어 모양을 알 수 없는 경우이고, 그 외의 경우는 온전히 남아 있는 경우다.

```
입력
6
-1 -1 -1 3 -1 -1

출력
3
```

```
6
-1 -1 2 -1 -1 -1

앞부분 2가지
뒷부분 5가지

답이 10이 나와야 하는데 12가 나온다 -> 10 나오게 바꿈
이것의 의미는 높이가 0일 때도 계산하는지의 여부이다.
1 –1 1의 경우
1 0 1
1 1 1
1 2 1 이 세 가지가 되지만 첫 번째 0의 경우는 제외한다.

위 문제처럼 –1이 연속된 부분별로 나눠서 경우의 수를 계산하고
그 경우의 수들을 곱해서 답을 구하는 문제다.

경우의 수를 구할 때는 재귀호출을 통해 distance가 1인 상황부터 
차곡차곡 계산해나가는 방식이다. (즉 x –1 y일 때부터 start –1 –1 –1 y를 계산)

distance가 1일 때
if (ABS(next - prev) == 2)
	return 1;
else if (ABS(next - prev) == 1)
	return 2;
else {
	if (prev == 1 && next == 1)
		return 2;
	return 3;
}
시간 초과 에러의 해결법 : 
DP[prev][next][distance]를 만들어서 메모이제이션 기법으로 시간 초과 에러를 해결했다.
```
